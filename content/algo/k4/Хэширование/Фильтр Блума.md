Фильтр Блума — это вероятностная структура данных, используемая для проверки принадлежности элемента множеству. Она позволяет с высокой вероятностью определить, принадлежит ли элемент множеству, при этом не сохраняя сами элементы. Фильтр Блума может дать ложные срабатывания (false positives), но никогда не дает ложных отрицаний (false negatives).

##  Основные характеристики

1. **Эффективность по памяти**: Фильтр Блума значительно экономит память по сравнению с традиционными структурами данных, такими как хеш-таблицы или массивы.
2. **Вероятностная структура**: Может дать ложное срабатывание, то есть сообщить, что элемент принадлежит множеству, хотя это не так.
3. **Отсутствие ложных отрицаний**: Если фильтр Блума сообщает, что элемента нет в множестве, то это всегда верно.

##  Принцип работы

Фильтр Блума состоит из битового массива и нескольких независимых хеш-функций. Когда элемент добавляется в фильтр Блума, он проходит через все хеш-функции, каждая из которых вычисляет один из индексов битового массива. Эти индексы устанавливаются в 1. При проверке элемента выполняется тот же процесс: если все соответствующие биты равны 1, то элемент, вероятно, находится в множестве; если хотя бы один бит равен 0, элемент точно отсутствует.

###  Добавление элемента

1. Пропустить элемент через все хеш-функции, получив несколько индексов.
2. Установить все биты в этих индексах в 1.

###  Проверка элемента

1. Пропустить элемент через все хеш-функции, получив несколько индексов.
2. Проверить значения битов в этих индексах.
3. Если все биты равны 1, элемент, вероятно, находится в множестве.
4. Если хотя бы один бит равен 0, элемент точно отсутствует в множестве.

##  Пример реализации на C++

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <functional> // Для std::hash

class BloomFilter {
private:
    std::vector<bool> bitArray;
    int size;
    int hashCount;

    // Простые хеш-функции, использующие std::hash
    int hash1(const std::string &str) {
        std::hash<std::string> hashFn;
        return hashFn(str) % size;
    }

    int hash2(const std::string &str) {
        std::hash<std::string> hashFn;
        return (hashFn(str) / size) % size;
    }

public:
    BloomFilter(int size, int hashCount) : size(size), hashCount(hashCount) {
        bitArray.resize(size, false);
    }

    void add(const std::string &str) {
        int hash1Value = hash1(str);
        int hash2Value = hash2(str);

        for (int i = 0; i < hashCount; ++i) {
            bitArray[(hash1Value + i * hash2Value) % size] = true;
        }
    }

    bool contains(const std::string &str) {
        int hash1Value = hash1(str);
        int hash2Value = hash2(str);

        for (int i = 0; i < hashCount; ++i) {
            if (!bitArray[(hash1Value + i * hash2Value) % size]) {
                return false;
            }
        }
        return true;
    }
};

int main() {
    BloomFilter bloomFilter(100, 3);

    bloomFilter.add("hello");
    bloomFilter.add("world");

    std::cout << "Contains 'hello': " << bloomFilter.contains("hello") << std::endl;
    std::cout << "Contains 'world': " << bloomFilter.contains("world") << std::endl;
    std::cout << "Contains 'test': " << bloomFilter.contains("test") << std::endl;

    return 0;
}
```

###  Объяснение кода

1. **Класс `BloomFilter`**:
   - Инициализируется битовый массив `bitArray`, размер `size` и количество хеш-функций `hashCount`.
   - Хеш-функции `hash1` и `hash2` используют `std::hash` для вычисления хешей.

2. **Метод `add`**:
   - Вычисляет хеш-значения с помощью `hash1` и `hash2`.
   - Устанавливает соответствующие биты в массиве `bitArray` в 1.

3. **Метод `contains`**:
   - Вычисляет хеш-значения с помощью `hash1` и `hash2`.
   - Проверяет, установлены ли соответствующие биты в массиве `bitArray`.
   - Возвращает `true`, если все биты равны 1, и `false`, если хотя бы один бит равен 0.

##  Преимущества фильтра Блума

1. **Экономия памяти**: Требует меньше памяти по сравнению с традиционными структурами данных.
2. **Быстрая вставка и проверка**: Операции вставки и проверки выполняются за постоянное время O(k), где k — количество хеш-функций.

##  Недостатки фильтра Блума

1. **Ложные срабатывания**: Может возвращать ложноположительные результаты.
2. **Невозможность удаления**: Не поддерживает удаление элементов, так как это может повлиять на другие элементы.
3. **Зависимость от количества хеш-функций**: Точность фильтра зависит от количества и качества используемых хеш-функций.

Фильтр Блума широко используется в различных приложениях, таких как базы данных, сетевые фильтры и распределенные системы, где важно быстрое и эффективное использование памяти при работе с большими объемами данных.