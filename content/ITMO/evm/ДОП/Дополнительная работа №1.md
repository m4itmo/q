#itmo 
![[Доп задание №1]]
# Код
```c
void InsertionSort(int *array_ptr, int n) {  
    __asm__(  
 			"mov %[array_ptr], %%rdi;"  
 			"mov $1, %%ecx;"
			"cmp %[N], %%ecx;"
			"jge end_sort;"
			"loop_start:;"
			"mov (%%rdi, %%rcx, 4), %%eax;"
			"mov %%ecx, %%edx;"
 			"dec %%edx;"
 			"inner_loop:;"
 			"mov (%%rdi, %%rdx, 4), %%ebx;"
 			"cmp %%ebx, %%eax;"
 			"jge inner_loop_skip;"
 			"mov %%ebx, (%%rdi, %%rcx, 4);"
 			"mov %%rdx, %%rcx;"
 			"dec %%rdx;"
 			"cmp $-1, %%rdx;"
 			"jge inner_loop;"
 			"inner_loop_skip:;"
 			"lea 1(%%rdx), %%rdx;"
 			"mov %%eax, (%%rdi, %%rdx, 4);"
 			"inc %%ecx;"
 			"cmp %[N], %%ecx;"
 			"jl loop_start;"
 			"end_sort:;"
 			:  
 			: [array_ptr] "m"(array_ptr), [N] "r"(n)  
    : "rax", "rbx", "rcx", "rdx", "rdi"  
    );  
}
```
# Теория
Этот код написан на языке C с использованием встроенного ассемблера для сортировки массива методом вставки. Давайте подробно разберем, как работает этот код:

### Функция InsertionSort

```c
void InsertionSort(int *array_ptr, int n) {
```

Функция принимает два аргумента:
1. `array_ptr` — указатель на массив целых чисел, который нужно отсортировать.
2. `n` — количество элементов в массиве.

### Встроенный ассемблер
[[Введение в Ассемблер]]
[[Синтаксис Ассемблера]]
[[Значения символов % и % %]]
```c
__asm__(
	"mov %[array_ptr], %%rdi;"  
	"mov $1, %%ecx;"
	"cmp %[N], %%ecx;"
	"jge end_sort;"
```
#### Инициализация
1. `mov %[array_ptr], %%rdi;` — загрузка адреса массива в регистр [[rdi]] используя [[mov]].
2. `mov $1, %%ecx;` — инициализация регистра [[ecx]] значением `1`. Это будет наш индекс текущего элемента, который мы вставляем в отсортированную часть массива.
3. `cmp %[N], %%ecx;` — сравнение длины массива с текущим индексом используя [[cmp]].
4. `jge end_sort;` — если текущий индекс не меньше длины массива, то перейти к метке `end_sort` используя [[jge]].

#### Основной цикл сортировки
```c
    "loop_start:;"
    "mov (%%rdi, %%rcx, 4), %%eax;"
    "mov %%ecx, %%edx;"
    "dec %%edx;"
```
1. `loop_start:;` — метка начала цикла.
2. `mov (%%rdi, %%rcx, 4), %%eax;` — загрузка текущего элемента массива в регистр [[eax]]. Здесь используется адресная арифметика для доступа к элементу массива `(%%rdi + %%rcx * 4)` (\%\%[[rdi]] + \%\%[[rcx]] * 4).
3. `mov %%ecx, %%edx;` — копирование значения индекса в регистр `edx` ([[ecx]] -> [[edx]]).
4. `dec %%edx;` — уменьшение значения `edx` на 1, чтобы получить индекс предыдущего элемента.

#### Внутренний цикл (перемещение элементов)
```c
    "inner_loop:;"
    "mov (%%rdi, %%rdx, 4), %%ebx;"
    "cmp %%ebx, %%eax;"
    "jge inner_loop_skip;"
    "mov %%ebx, (%%rdi, %%rcx, 4);"
    "mov %%rdx, %%rcx;"
    "dec %%rdx;"
    "cmp $-1, %%rdx;"
    "jge inner_loop;"
```

1. `inner_loop:;` — метка начала внутреннего цикла.
2. `mov (%%rdi, %%rdx, 4), %%ebx;` — загрузка предыдущего элемента массива в регистр [[ebx]].
3. `cmp %%ebx, %%eax;` — сравнение предыдущего элемента с текущим.
4. `jge inner_loop_skip;` — если предыдущий элемент больше или равен текущему, переход к метке `inner_loop_skip`.
5. `mov %%ebx, (%%rdi, %%rcx, 4);` — перемещение предыдущего элемента на позицию текущего.
6. `mov %%rdx, %%rcx;` — обновление текущего индекса ([[rdx]]).
7. `dec %%rdx;` — уменьшение индекса предыдущего элемента ([[dec]]).
8. `cmp $-1, %%rdx;` — проверка, не достигнут ли индекс -1.
9. `jge inner_loop;` — если индекс не меньше 0, повторить внутренний цикл.

#### Пропуск и завершение внутреннего цикла

```c
    "inner_loop_skip:;"
    "lea 1(%%rdx), %%rdx;"
    "mov %%eax, (%%rdi, %%rdx, 4);"
    "inc %%ecx;"
    "cmp %[N], %%ecx;"
    "jl loop_start;"
```

1. `inner_loop_skip:;` — метка для пропуска перемещения.
2. `lea 1(%%rdx), %%rdx;` — увеличение `rdx` на 1, чтобы получить корректный индекс для вставки ([[lea]]).
   [[Объяснение синтаксиса lea 1(...)]]
3. `mov %%eax, (%%rdi, %%rdx, 4);` — вставка текущего элемента на правильное место.
4. `inc %%ecx;` — увеличение индекса текущего элемента ([[inc]]).
5. `cmp %[N], %%ecx;` — проверка, не достигнут ли конец массива.
6. `jl loop_start;` — если конец массива не достигнут, повторить внешний цикл ([[jl]]).

#### Завершение сортировки

```c
    "end_sort:;"
    :
    : [array_ptr] "m"(array_ptr), [N] "r"(n)
    : "rax", "rbx", "rcx", "rdx", "rdi"
);
}
```

1. `end_sort:;` — метка завершения сортировки.
2. `:` — секция для указания выходных операндов (в данном случае отсутствует).
3. `: [array_ptr] "m"(array_ptr), [N] "r"(n)` — секция для указания входных операндов:
    - `[array_ptr] "m"(array_ptr)` — адрес массива.
    - `[N] "r"(n)` — длина массива.
4. `: "rax", "rbx", "rcx", "rdx", "rdi"` — секция для указания изменяемых регистров (clobbered registers) ([[rax]], [[rbx]], [[rcx]], [[rdx]], [[rdi]]).

Этот код сортирует массив целых чисел методом вставки, используя встроенный ассемблер для оптимизации производительности.