[[Введение в Ассемблер]]
## Синтаксис Языка Ассемблера: Обзор Основных Конструкций

Ассемблер — это низкоуровневый язык программирования, который напрямую взаимодействует с архитектурой процессора. В этой статье мы рассмотрим основные синтаксические элементы ассемблера, такие как специальные символы, регистры и директивы. Понимание этих элементов поможет вам более эффективно писать и читать код на ассемблере.

### Основные Синтаксические Конструкции

#### Регистры

Регистры — это специальные ячейки памяти внутри процессора, которые используются для хранения данных и адресов. В x86 архитектуре существуют следующие основные регистры:

- **Общие регистры**: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.
- **Сегментные регистры**: CS, DS, ES, FS, GS, SS.
- **Указатели и индексные регистры**: EIP, EFLAGS.

#### Символы и их Значения

1. **%** и **\%\%**:

   В некоторых ассемблерах, например, GNU Assembler (GAS), символ `%` используется для обозначения регистров. Например:

   ```assembly
   mov %eax, %ebx  ; Копировать значение из регистра EAX в регистр EBX
   ```

   Символ `%%` используется для обозначения меток в макросах:

   ```assembly
   .macro mymacro
   %%label:
       nop
   .endm
   ```

2. **\[\]**:

   Квадратные скобки используются для обозначения адресации памяти. Например:

   ```assembly
   mov eax, [ebx]  ; Загрузить значение по адресу, хранящемуся в EBX, в EAX
   mov [ebx], eax  ; Сохранить значение из EAX по адресу, хранящемуся в EBX
   ```

3. **$**:

   В GAS символ `$` используется для обозначения немедленного (константного) значения:

   ```assembly
   mov $5, %eax  ; Загрузить значение 5 в регистр EAX
   ```

   Также `$` может использоваться для обозначения текущей адресной метки:

   ```assembly
   jmp $         ; Бесконечный цикл, переход на текущую инструкцию
   ```

4. **@**:
   В некоторых ассемблерах символ `@` используется для обозначения комментариев. Например, в ARM Assembly:

   ```assembly
   MOV R0, #1  @ Загрузить значение 1 в регистр R0
   ```

5. **\#**:
   Символ `#` часто используется для обозначения немедленных значений в ARM Assembly:

   ```assembly
   MOV R0, #1  ; Загрузить значение 1 в регистр R0
   ```
   
1. **\:** (**Символ :**)\:
	Символ `:` имеет важное значение в синтаксисе ассемблера и используется в нескольких контекстах, главным образом для обозначения меток и разделения сегментов.
	
	#### Метки
	Одна из основных функций символа `:` — это обозначение меток. Метки используются для указания определённых мест в коде, к которым можно перейти с помощью инструкций перехода (jump) или вызвать подпрограммы. Метка представляет собой имя, за которым следует двоеточие.
	Например:
	```assembly
	start:
	    mov eax, 1
	    jmp end
	
	end:
	    mov ebx, 0
	```
	
	В этом примере `start:` и `end:` являются метками, которые указывают на конкретные инструкции в программе. Инструкция `jmp end` осуществляет переход к метке `end`.
	
	#### Сегменты данных и кода
	В некоторых ассемблерах символ `:` также может использоваться в директивах, определяющих сегменты данных и кода.
	Например:
	```assembly
	section .data
	    msg db 'Hello, World!', 0
	
	section .text
	    global _start
	
	_start:
	    mov eax, 4
	    mov ebx, 1
	    mov ecx, msg
	    mov edx, 13
	    int 0x80
	```
	
	Здесь директивы `section .data:` и `section .text:` используются для определения сегментов данных и кода соответственно. Хотя в большинстве ассемблеров синтаксис с двоеточием не всегда требуется, его использование может быть стилевым предпочтением или требованием конкретного ассемблера.
	
	#### Примеры использования символа `:`
	1. **Определение меток**:
	   ```assembly
	   loop_start:
	       ; Начало цикла
	       cmp eax, 0
	       je loop_end
	       dec eax
	       jmp loop_start
	
	   loop_end:
	       ; Конец цикла
	   ```
	
	   В этом примере `loop_start:` и `loop_end:` определяют начало и конец цикла. Инструкция `jmp loop_start` организует цикл, пока значение в регистре `eax` не станет нулевым.
	
	2. **Определение сегментов**:
	   ```assembly
	   section .data
	   message db 'Hello, World!', 0
	
	   section .text
	   global _start
	
	   _start:
	       mov edx, len   ; Длина сообщения
	       mov ecx, message ; Адрес сообщения
	       mov ebx, 1     ; Дескриптор stdout
	       mov eax, 4     ; Системный вызов write
	       int 0x80       ; Вызов ядра Linux
	
	       mov eax, 1     ; Системный вызов exit
	       int 0x80       ; Вызов ядра Linux
	
	   len equ $ - message
	   ```
	   
	   В данном случае используются метки `_start:` для указания начала исполнения программы и сегменты `.data` и `.text` для определения данных и кода соответственно.

#### Директивы

Директивы — это инструкции для ассемблера, которые не являются командами процессора, но управляют процессом сборки. Вот некоторые часто используемые директивы:

- **section**: Определяет сегмент кода или данных.

  ```assembly
  section .data
      msg db 'Hello, World!', 0
  ```

- **global**: Объявляет глобальную метку, доступную из других файлов.

  ```assembly
  global _start
  ```

- **extern**: Объявляет внешнюю метку, определенную в другом файле.

  ```assembly
  extern printf
  ```

- **db, dw, dd**: Определяют данные в памяти (байты, слова, двойные слова).

  ```assembly
  db 0x55       ; Определить байт
  dw 0x1234     ; Определить слово (2 байта)
  dd 0x12345678 ; Определить двойное слово (4 байта)
  ```

### Пример программы

Для лучшего понимания приведем пример простой программы на ассемблере:

```assembly
section .data
    msg db 'Hello, World!', 0

section .text
    global _start

_start:
    ; Write the message to stdout
    mov eax, 4        ; Системный вызов write
    mov ebx, 1        ; Дескриптор stdout
    mov ecx, msg      ; Адрес сообщения
    mov edx, 13       ; Длина сообщения
    int 0x80          ; Вызов ядра Linux

    ; Exit the program
    mov eax, 1        ; Системный вызов exit
    xor ebx, ebx      ; Код возврата 0
    int 0x80          ; Вызов ядра Linux
```

Этот пример демонстрирует использование регистров, немедленных значений и адресации памяти.

### Заключение

Понимание синтаксиса ассемблера — важный шаг на пути к эффективному программированию на этом низкоуровневом языке. Освоив основные конструкции и символы, вы сможете создавать программы, которые используют полный потенциал вашего процессора, обеспечивая высокую производительность и контроль над аппаратными ресурсами.