---
title: Команда cmp в arm ассемблере
---
# Введение

Команда `cmp` (сокращение от "compare" - сравнивать) является одной из основных команд в языке ассемблера, используемая для сравнения двух значений. Она выполняет вычитание одного значения из другого, не сохраняя результат, но устанавливая флаги состояния процессора, которые используются для принятия решений в дальнейшем коде. В этой статье мы подробно рассмотрим работу команды `cmp`, её синтаксис, различные варианты использования и примеры.

# Основная часть

## Синтаксис команды `cmp`

Команда `cmp` используется для сравнения двух операндов. Общий синтаксис команды `cmp` следующий:

```assembly
cmp operand1, operand2
```

Где `operand1` и `operand2` могут быть регистрами, непосредственными значениями или адресами памяти.

### Принцип работы

Команда `cmp` фактически выполняет операцию вычитания: `operand1 - operand2`, но результат этой операции не сохраняется. Вместо этого устанавливаются флаги состояния процессора, такие как Zero (Z), Negative (N), Carry (C) и Overflow (V), которые могут быть использованы в последующих условных переходах.

### Примеры использования команды `cmp`

#### Пример 1: Сравнение регистров

Рассмотрим пример на языке ассемблера для архитектуры ARM:

```assembly
cmp x0, x1
```

В этом примере сравниваются значения, хранящиеся в регистрах `x0` и `x1`. В зависимости от результата сравнения устанавливаются флаги состояния процессора.

#### Пример 2: Сравнение регистра с непосредственным значением

```assembly
cmp x0, #10
```

В этом примере значение в регистре `x0` сравнивается с числом `10`.

### Использование результатов сравнения

После выполнения команды `cmp` флаги состояния процессора могут быть использованы в условных переходах для принятия решений в коде. Рассмотрим несколько примеров.

#### Пример 3: Условный переход при равенстве

```assembly
cmp x0, x1
beq labels_equal
```

Если значения в регистрах `x0` и `x1` равны, управление перейдет к метке `labels_equal`.

#### Пример 4: Условный переход при неравенстве

```assembly
cmp x0, #5
bne label_not_equal
```

Если значение в регистре `x0` не равно `5`, управление перейдет к метке `label_not_equal`.

#### Пример 5: Условный переход при большем значении

```assembly
cmp x0, x1
bgt label_greater
```

Если значение в регистре `x0` больше значения в регистре `x1`, управление перейдет к метке `label_greater`.

#### Пример 6: Условный переход при меньшем значении

```assembly
cmp x0, x1
blt label_less
```

Если значение в регистре `x0` меньше значения в регистре `x1`, управление перейдет к метке `label_less`.

### Примеры комплексного использования

#### Пример 7: Реализация цикла с использованием `cmp` и условного перехода

Рассмотрим пример цикла, который выполняется, пока значение в регистре `x0` не достигнет 10:

```assembly
mov x0, #0        // Инициализация x0 в 0
loop_start:
cmp x0, #10       // Сравнение x0 с 10
bge loop_end      // Переход к loop_end, если x0 >= 10
// (Тело цикла)
add x0, x0, #1    // Увеличение x0 на 1
b loop_start      // Переход к началу цикла
loop_end:
```

Этот пример демонстрирует, как команда `cmp` используется в сочетании с условными переходами для создания цикла.

# Вывод

Команда `cmp` играет важную роль в ассемблерном программировании, позволяя эффективно сравнивать значения и принимать решения на основе этих сравнений. Понимание принципов работы команды `cmp` и умение использовать её в различных ситуациях является ключевым для написания логически сложных и оптимизированных программ на ассемблере. Благодаря `cmp` можно создавать условные переходы, циклы и другие конструкции, необходимые для реализации алгоритмов и контроля потока выполнения программы.